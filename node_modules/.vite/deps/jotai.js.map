{
  "version": 3,
  "sources": ["../../jotai/esm/vanilla/internals.mjs", "../../jotai/esm/vanilla.mjs", "../../jotai/esm/react.mjs"],
  "sourcesContent": ["function hasInitialValue(atom) {\n  return \"init\" in atom;\n}\nfunction isActuallyWritableAtom(atom) {\n  return !!atom.write;\n}\nfunction isAtomStateInitialized(atomState) {\n  return \"v\" in atomState || \"e\" in atomState;\n}\nfunction returnAtomValue(atomState) {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !(\"v\" in atomState)) {\n    throw new Error(\"[Bug] atom state is not initialized\");\n  }\n  return atomState.v;\n}\nfunction isPromiseLike(p) {\n  return typeof (p == null ? void 0 : p.then) === \"function\";\n}\nfunction addPendingPromiseToDependency(atom, promise, dependencyAtomState) {\n  if (!dependencyAtomState.p.has(atom)) {\n    dependencyAtomState.p.add(atom);\n    const cleanup = () => dependencyAtomState.p.delete(atom);\n    promise.then(cleanup, cleanup);\n  }\n}\nfunction getMountedOrPendingDependents(atom, atomState, mountedMap) {\n  var _a;\n  const dependents = /* @__PURE__ */ new Set();\n  for (const a of ((_a = mountedMap.get(atom)) == null ? void 0 : _a.t) || []) {\n    dependents.add(a);\n  }\n  for (const atomWithPendingPromise of atomState.p) {\n    dependents.add(atomWithPendingPromise);\n  }\n  return dependents;\n}\nconst createStoreHook = () => {\n  const callbacks = /* @__PURE__ */ new Set();\n  const notify = () => callbacks.forEach((fn) => fn());\n  notify.add = (fn) => {\n    callbacks.add(fn);\n    return () => callbacks.delete(fn);\n  };\n  return notify;\n};\nconst createStoreHookForAtoms = () => {\n  const all = {};\n  const callbacks = /* @__PURE__ */ new WeakMap();\n  const notify = (atom) => {\n    var _a, _b;\n    (_a = callbacks.get(all)) == null ? void 0 : _a.forEach((fn) => fn(atom));\n    (_b = callbacks.get(atom)) == null ? void 0 : _b.forEach((fn) => fn());\n  };\n  notify.add = (atom, fn) => {\n    const key = atom || all;\n    let fns = callbacks.get(key);\n    if (!fns) {\n      fns = /* @__PURE__ */ new Set();\n      callbacks.set(key, fns);\n    }\n    fns.add(fn);\n    return () => {\n      fns.delete(fn);\n      if (!fns.size) {\n        callbacks.delete(key);\n      }\n    };\n  };\n  return notify;\n};\nfunction initializeStoreHooks(storeHooks) {\n  storeHooks.i || (storeHooks.i = createStoreHookForAtoms());\n  storeHooks.r || (storeHooks.r = createStoreHookForAtoms());\n  storeHooks.c || (storeHooks.c = createStoreHookForAtoms());\n  storeHooks.m || (storeHooks.m = createStoreHookForAtoms());\n  storeHooks.u || (storeHooks.u = createStoreHookForAtoms());\n  storeHooks.f || (storeHooks.f = createStoreHook());\n  return storeHooks;\n}\nconst BUILDING_BLOCK_atomRead = (_store, atom, ...params) => atom.read(...params);\nconst BUILDING_BLOCK_atomWrite = (_store, atom, ...params) => atom.write(...params);\nconst BUILDING_BLOCK_atomOnInit = (store, atom) => {\n  var _a;\n  return (_a = atom.INTERNAL_onInit) == null ? void 0 : _a.call(atom, store);\n};\nconst BUILDING_BLOCK_atomOnMount = (_store, atom, setAtom) => {\n  var _a;\n  return (_a = atom.onMount) == null ? void 0 : _a.call(atom, setAtom);\n};\nconst BUILDING_BLOCK_ensureAtomState = (store, atom) => {\n  var _a;\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const atomStateMap = buildingBlocks[0];\n  const storeHooks = buildingBlocks[6];\n  const atomOnInit = buildingBlocks[9];\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !atom) {\n    throw new Error(\"Atom is undefined or null\");\n  }\n  let atomState = atomStateMap.get(atom);\n  if (!atomState) {\n    atomState = { d: /* @__PURE__ */ new Map(), p: /* @__PURE__ */ new Set(), n: 0 };\n    atomStateMap.set(atom, atomState);\n    (_a = storeHooks.i) == null ? void 0 : _a.call(storeHooks, atom);\n    atomOnInit == null ? void 0 : atomOnInit(store, atom);\n  }\n  return atomState;\n};\nconst BUILDING_BLOCK_flushCallbacks = (store) => {\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const mountedMap = buildingBlocks[1];\n  const changedAtoms = buildingBlocks[3];\n  const mountCallbacks = buildingBlocks[4];\n  const unmountCallbacks = buildingBlocks[5];\n  const storeHooks = buildingBlocks[6];\n  const recomputeInvalidatedAtoms = buildingBlocks[13];\n  const errors = [];\n  const call = (fn) => {\n    try {\n      fn();\n    } catch (e) {\n      errors.push(e);\n    }\n  };\n  do {\n    if (storeHooks.f) {\n      call(storeHooks.f);\n    }\n    const callbacks = /* @__PURE__ */ new Set();\n    const add = callbacks.add.bind(callbacks);\n    changedAtoms.forEach((atom) => {\n      var _a;\n      return (_a = mountedMap.get(atom)) == null ? void 0 : _a.l.forEach(add);\n    });\n    changedAtoms.clear();\n    unmountCallbacks.forEach(add);\n    unmountCallbacks.clear();\n    mountCallbacks.forEach(add);\n    mountCallbacks.clear();\n    callbacks.forEach(call);\n    if (changedAtoms.size) {\n      recomputeInvalidatedAtoms(store);\n    }\n  } while (changedAtoms.size || unmountCallbacks.size || mountCallbacks.size);\n  if (errors.length) {\n    throw new AggregateError(errors);\n  }\n};\nconst BUILDING_BLOCK_recomputeInvalidatedAtoms = (store) => {\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const mountedMap = buildingBlocks[1];\n  const invalidatedAtoms = buildingBlocks[2];\n  const changedAtoms = buildingBlocks[3];\n  const ensureAtomState = buildingBlocks[11];\n  const readAtomState = buildingBlocks[14];\n  const mountDependencies = buildingBlocks[17];\n  const topSortedReversed = [];\n  const visiting = /* @__PURE__ */ new WeakSet();\n  const visited = /* @__PURE__ */ new WeakSet();\n  const stack = Array.from(changedAtoms);\n  while (stack.length) {\n    const a = stack[stack.length - 1];\n    const aState = ensureAtomState(store, a);\n    if (visited.has(a)) {\n      stack.pop();\n      continue;\n    }\n    if (visiting.has(a)) {\n      if (invalidatedAtoms.get(a) === aState.n) {\n        topSortedReversed.push([a, aState]);\n      } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && invalidatedAtoms.has(a)) {\n        throw new Error(\"[Bug] invalidated atom exists\");\n      }\n      visited.add(a);\n      stack.pop();\n      continue;\n    }\n    visiting.add(a);\n    for (const d of getMountedOrPendingDependents(a, aState, mountedMap)) {\n      if (!visiting.has(d)) {\n        stack.push(d);\n      }\n    }\n  }\n  for (let i = topSortedReversed.length - 1; i >= 0; --i) {\n    const [a, aState] = topSortedReversed[i];\n    let hasChangedDeps = false;\n    for (const dep of aState.d.keys()) {\n      if (dep !== a && changedAtoms.has(dep)) {\n        hasChangedDeps = true;\n        break;\n      }\n    }\n    if (hasChangedDeps) {\n      readAtomState(store, a);\n      mountDependencies(store, a);\n    }\n    invalidatedAtoms.delete(a);\n  }\n};\nconst storeMutationSet = /* @__PURE__ */ new WeakSet();\nconst BUILDING_BLOCK_readAtomState = (store, atom) => {\n  var _a, _b;\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const mountedMap = buildingBlocks[1];\n  const invalidatedAtoms = buildingBlocks[2];\n  const changedAtoms = buildingBlocks[3];\n  const storeHooks = buildingBlocks[6];\n  const atomRead = buildingBlocks[7];\n  const ensureAtomState = buildingBlocks[11];\n  const flushCallbacks = buildingBlocks[12];\n  const recomputeInvalidatedAtoms = buildingBlocks[13];\n  const readAtomState = buildingBlocks[14];\n  const writeAtomState = buildingBlocks[16];\n  const mountDependencies = buildingBlocks[17];\n  const setAtomStateValueOrPromise = buildingBlocks[20];\n  const registerAbortHandler = buildingBlocks[26];\n  const atomState = ensureAtomState(store, atom);\n  if (isAtomStateInitialized(atomState)) {\n    if (mountedMap.has(atom) && invalidatedAtoms.get(atom) !== atomState.n) {\n      return atomState;\n    }\n    let hasChangedDeps = false;\n    for (const [a, n] of atomState.d) {\n      if (readAtomState(store, a).n !== n) {\n        hasChangedDeps = true;\n        break;\n      }\n    }\n    if (!hasChangedDeps) {\n      return atomState;\n    }\n  }\n  let isSync = true;\n  const prevDeps = new Set(atomState.d.keys());\n  const nextDeps = /* @__PURE__ */ new Map();\n  const pruneDependencies = () => {\n    for (const a of prevDeps) {\n      if (!nextDeps.has(a)) {\n        atomState.d.delete(a);\n      }\n    }\n  };\n  const mountDependenciesIfAsync = () => {\n    if (mountedMap.has(atom)) {\n      const shouldRecompute = !changedAtoms.size;\n      mountDependencies(store, atom);\n      if (shouldRecompute) {\n        recomputeInvalidatedAtoms(store);\n        flushCallbacks(store);\n      }\n    }\n  };\n  const getter = (a) => {\n    var _a2;\n    if (a === atom) {\n      const aState2 = ensureAtomState(store, a);\n      if (!isAtomStateInitialized(aState2)) {\n        if (hasInitialValue(a)) {\n          setAtomStateValueOrPromise(store, a, a.init);\n        } else {\n          throw new Error(\"no atom init\");\n        }\n      }\n      return returnAtomValue(aState2);\n    }\n    const aState = readAtomState(store, a);\n    try {\n      return returnAtomValue(aState);\n    } finally {\n      nextDeps.set(a, aState.n);\n      atomState.d.set(a, aState.n);\n      if (isPromiseLike(atomState.v)) {\n        addPendingPromiseToDependency(atom, atomState.v, aState);\n      }\n      if (mountedMap.has(atom)) {\n        (_a2 = mountedMap.get(a)) == null ? void 0 : _a2.t.add(atom);\n      }\n      if (!isSync) {\n        mountDependenciesIfAsync();\n      }\n    }\n  };\n  let controller;\n  let setSelf;\n  const options = {\n    get signal() {\n      if (!controller) {\n        controller = new AbortController();\n      }\n      return controller.signal;\n    },\n    get setSelf() {\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        console.warn(\n          \"[DEPRECATED] setSelf is deprecated and will be removed in v3.\"\n        );\n      }\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !isActuallyWritableAtom(atom)) {\n        console.warn(\"setSelf function cannot be used with read-only atom\");\n      }\n      if (!setSelf && isActuallyWritableAtom(atom)) {\n        setSelf = (...args) => {\n          if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && isSync) {\n            console.warn(\"setSelf function cannot be called in sync\");\n          }\n          if (!isSync) {\n            try {\n              return writeAtomState(store, atom, ...args);\n            } finally {\n              recomputeInvalidatedAtoms(store);\n              flushCallbacks(store);\n            }\n          }\n        };\n      }\n      return setSelf;\n    }\n  };\n  const prevEpochNumber = atomState.n;\n  try {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      storeMutationSet.delete(store);\n    }\n    const valueOrPromise = atomRead(store, atom, getter, options);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && storeMutationSet.has(store)) {\n      console.warn(\n        \"Detected store mutation during atom read. This is not supported.\"\n      );\n    }\n    setAtomStateValueOrPromise(store, atom, valueOrPromise);\n    if (isPromiseLike(valueOrPromise)) {\n      registerAbortHandler(store, valueOrPromise, () => controller == null ? void 0 : controller.abort());\n      const settle = () => {\n        pruneDependencies();\n        mountDependenciesIfAsync();\n      };\n      valueOrPromise.then(settle, settle);\n    } else {\n      pruneDependencies();\n    }\n    (_a = storeHooks.r) == null ? void 0 : _a.call(storeHooks, atom);\n    return atomState;\n  } catch (error) {\n    delete atomState.v;\n    atomState.e = error;\n    ++atomState.n;\n    return atomState;\n  } finally {\n    isSync = false;\n    if (prevEpochNumber !== atomState.n && invalidatedAtoms.get(atom) === prevEpochNumber) {\n      invalidatedAtoms.set(atom, atomState.n);\n      changedAtoms.add(atom);\n      (_b = storeHooks.c) == null ? void 0 : _b.call(storeHooks, atom);\n    }\n  }\n};\nconst BUILDING_BLOCK_invalidateDependents = (store, atom) => {\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const mountedMap = buildingBlocks[1];\n  const invalidatedAtoms = buildingBlocks[2];\n  const ensureAtomState = buildingBlocks[11];\n  const stack = [atom];\n  while (stack.length) {\n    const a = stack.pop();\n    const aState = ensureAtomState(store, a);\n    for (const d of getMountedOrPendingDependents(a, aState, mountedMap)) {\n      const dState = ensureAtomState(store, d);\n      if (invalidatedAtoms.get(d) !== dState.n) {\n        invalidatedAtoms.set(d, dState.n);\n        stack.push(d);\n      }\n    }\n  }\n};\nconst BUILDING_BLOCK_writeAtomState = (store, atom, ...args) => {\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const changedAtoms = buildingBlocks[3];\n  const storeHooks = buildingBlocks[6];\n  const atomWrite = buildingBlocks[8];\n  const ensureAtomState = buildingBlocks[11];\n  const flushCallbacks = buildingBlocks[12];\n  const recomputeInvalidatedAtoms = buildingBlocks[13];\n  const readAtomState = buildingBlocks[14];\n  const invalidateDependents = buildingBlocks[15];\n  const writeAtomState = buildingBlocks[16];\n  const mountDependencies = buildingBlocks[17];\n  const setAtomStateValueOrPromise = buildingBlocks[20];\n  let isSync = true;\n  const getter = (a) => returnAtomValue(readAtomState(store, a));\n  const setter = (a, ...args2) => {\n    var _a;\n    const aState = ensureAtomState(store, a);\n    try {\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n          storeMutationSet.add(store);\n        }\n        const prevEpochNumber = aState.n;\n        const v = args2[0];\n        setAtomStateValueOrPromise(store, a, v);\n        mountDependencies(store, a);\n        if (prevEpochNumber !== aState.n) {\n          changedAtoms.add(a);\n          invalidateDependents(store, a);\n          (_a = storeHooks.c) == null ? void 0 : _a.call(storeHooks, a);\n        }\n        return void 0;\n      } else {\n        return writeAtomState(store, a, ...args2);\n      }\n    } finally {\n      if (!isSync) {\n        recomputeInvalidatedAtoms(store);\n        flushCallbacks(store);\n      }\n    }\n  };\n  try {\n    return atomWrite(store, atom, getter, setter, ...args);\n  } finally {\n    isSync = false;\n  }\n};\nconst BUILDING_BLOCK_mountDependencies = (store, atom) => {\n  var _a;\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const mountedMap = buildingBlocks[1];\n  const changedAtoms = buildingBlocks[3];\n  const storeHooks = buildingBlocks[6];\n  const ensureAtomState = buildingBlocks[11];\n  const invalidateDependents = buildingBlocks[15];\n  const mountAtom = buildingBlocks[18];\n  const unmountAtom = buildingBlocks[19];\n  const atomState = ensureAtomState(store, atom);\n  const mounted = mountedMap.get(atom);\n  if (mounted) {\n    for (const [a, n] of atomState.d) {\n      if (!mounted.d.has(a)) {\n        const aState = ensureAtomState(store, a);\n        const aMounted = mountAtom(store, a);\n        aMounted.t.add(atom);\n        mounted.d.add(a);\n        if (n !== aState.n) {\n          changedAtoms.add(a);\n          invalidateDependents(store, a);\n          (_a = storeHooks.c) == null ? void 0 : _a.call(storeHooks, a);\n        }\n      }\n    }\n    for (const a of mounted.d) {\n      if (!atomState.d.has(a)) {\n        mounted.d.delete(a);\n        const aMounted = unmountAtom(store, a);\n        aMounted == null ? void 0 : aMounted.t.delete(atom);\n      }\n    }\n  }\n};\nconst BUILDING_BLOCK_mountAtom = (store, atom) => {\n  var _a;\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const mountedMap = buildingBlocks[1];\n  const mountCallbacks = buildingBlocks[4];\n  const storeHooks = buildingBlocks[6];\n  const atomOnMount = buildingBlocks[10];\n  const ensureAtomState = buildingBlocks[11];\n  const flushCallbacks = buildingBlocks[12];\n  const recomputeInvalidatedAtoms = buildingBlocks[13];\n  const readAtomState = buildingBlocks[14];\n  const writeAtomState = buildingBlocks[16];\n  const mountAtom = buildingBlocks[18];\n  const atomState = ensureAtomState(store, atom);\n  let mounted = mountedMap.get(atom);\n  if (!mounted) {\n    readAtomState(store, atom);\n    for (const a of atomState.d.keys()) {\n      const aMounted = mountAtom(store, a);\n      aMounted.t.add(atom);\n    }\n    mounted = {\n      l: /* @__PURE__ */ new Set(),\n      d: new Set(atomState.d.keys()),\n      t: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if (isActuallyWritableAtom(atom)) {\n      const processOnMount = () => {\n        let isSync = true;\n        const setAtom = (...args) => {\n          try {\n            return writeAtomState(store, atom, ...args);\n          } finally {\n            if (!isSync) {\n              recomputeInvalidatedAtoms(store);\n              flushCallbacks(store);\n            }\n          }\n        };\n        try {\n          const onUnmount = atomOnMount(store, atom, setAtom);\n          if (onUnmount) {\n            mounted.u = () => {\n              isSync = true;\n              try {\n                onUnmount();\n              } finally {\n                isSync = false;\n              }\n            };\n          }\n        } finally {\n          isSync = false;\n        }\n      };\n      mountCallbacks.add(processOnMount);\n    }\n    (_a = storeHooks.m) == null ? void 0 : _a.call(storeHooks, atom);\n  }\n  return mounted;\n};\nconst BUILDING_BLOCK_unmountAtom = (store, atom) => {\n  var _a, _b;\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const mountedMap = buildingBlocks[1];\n  const unmountCallbacks = buildingBlocks[5];\n  const storeHooks = buildingBlocks[6];\n  const ensureAtomState = buildingBlocks[11];\n  const unmountAtom = buildingBlocks[19];\n  const atomState = ensureAtomState(store, atom);\n  let mounted = mountedMap.get(atom);\n  if (!mounted || mounted.l.size) {\n    return mounted;\n  }\n  let isDependent = false;\n  for (const a of mounted.t) {\n    if ((_a = mountedMap.get(a)) == null ? void 0 : _a.d.has(atom)) {\n      isDependent = true;\n      break;\n    }\n  }\n  if (!isDependent) {\n    if (mounted.u) {\n      unmountCallbacks.add(mounted.u);\n    }\n    mounted = void 0;\n    mountedMap.delete(atom);\n    for (const a of atomState.d.keys()) {\n      const aMounted = unmountAtom(store, a);\n      aMounted == null ? void 0 : aMounted.t.delete(atom);\n    }\n    (_b = storeHooks.u) == null ? void 0 : _b.call(storeHooks, atom);\n    return void 0;\n  }\n  return mounted;\n};\nconst BUILDING_BLOCK_setAtomStateValueOrPromise = (store, atom, valueOrPromise) => {\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const ensureAtomState = buildingBlocks[11];\n  const abortPromise = buildingBlocks[27];\n  const atomState = ensureAtomState(store, atom);\n  const hasPrevValue = \"v\" in atomState;\n  const prevValue = atomState.v;\n  if (isPromiseLike(valueOrPromise)) {\n    for (const a of atomState.d.keys()) {\n      addPendingPromiseToDependency(\n        atom,\n        valueOrPromise,\n        ensureAtomState(store, a)\n      );\n    }\n  }\n  atomState.v = valueOrPromise;\n  delete atomState.e;\n  if (!hasPrevValue || !Object.is(prevValue, atomState.v)) {\n    ++atomState.n;\n    if (isPromiseLike(prevValue)) {\n      abortPromise(store, prevValue);\n    }\n  }\n};\nconst BUILDING_BLOCK_storeGet = (store, atom) => {\n  const readAtomState = getInternalBuildingBlocks(store)[14];\n  return returnAtomValue(readAtomState(store, atom));\n};\nconst BUILDING_BLOCK_storeSet = (store, atom, ...args) => {\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const flushCallbacks = buildingBlocks[12];\n  const recomputeInvalidatedAtoms = buildingBlocks[13];\n  const writeAtomState = buildingBlocks[16];\n  try {\n    return writeAtomState(store, atom, ...args);\n  } finally {\n    recomputeInvalidatedAtoms(store);\n    flushCallbacks(store);\n  }\n};\nconst BUILDING_BLOCK_storeSub = (store, atom, listener) => {\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const flushCallbacks = buildingBlocks[12];\n  const mountAtom = buildingBlocks[18];\n  const unmountAtom = buildingBlocks[19];\n  const mounted = mountAtom(store, atom);\n  const listeners = mounted.l;\n  listeners.add(listener);\n  flushCallbacks(store);\n  return () => {\n    listeners.delete(listener);\n    unmountAtom(store, atom);\n    flushCallbacks(store);\n  };\n};\nconst BUILDING_BLOCK_registerAbortHandler = (store, promise, abortHandler) => {\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const abortHandlersMap = buildingBlocks[25];\n  let abortHandlers = abortHandlersMap.get(promise);\n  if (!abortHandlers) {\n    abortHandlers = /* @__PURE__ */ new Set();\n    abortHandlersMap.set(promise, abortHandlers);\n    const cleanup = () => abortHandlersMap.delete(promise);\n    promise.then(cleanup, cleanup);\n  }\n  abortHandlers.add(abortHandler);\n};\nconst BUILDING_BLOCK_abortPromise = (store, promise) => {\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const abortHandlersMap = buildingBlocks[25];\n  const abortHandlers = abortHandlersMap.get(promise);\n  abortHandlers == null ? void 0 : abortHandlers.forEach((fn) => fn());\n};\nconst buildingBlockMap = /* @__PURE__ */ new WeakMap();\nconst getInternalBuildingBlocks = (store) => {\n  const buildingBlocks = buildingBlockMap.get(store);\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !buildingBlocks) {\n    throw new Error(\n      \"Store must be created by buildStore to read its building blocks\"\n    );\n  }\n  return buildingBlocks;\n};\nfunction getBuildingBlocks(store) {\n  const buildingBlocks = getInternalBuildingBlocks(store);\n  const enhanceBuildingBlocks = buildingBlocks[24];\n  if (enhanceBuildingBlocks) {\n    return enhanceBuildingBlocks(buildingBlocks);\n  }\n  return buildingBlocks;\n}\nfunction buildStore(...buildArgs) {\n  const store = {\n    get(atom) {\n      const storeGet = getInternalBuildingBlocks(store)[21];\n      return storeGet(store, atom);\n    },\n    set(atom, ...args) {\n      const storeSet = getInternalBuildingBlocks(store)[22];\n      return storeSet(store, atom, ...args);\n    },\n    sub(atom, listener) {\n      const storeSub = getInternalBuildingBlocks(store)[23];\n      return storeSub(store, atom, listener);\n    }\n  };\n  const buildingBlocks = [\n    // store state\n    /* @__PURE__ */ new WeakMap(),\n    // atomStateMap\n    /* @__PURE__ */ new WeakMap(),\n    // mountedMap\n    /* @__PURE__ */ new WeakMap(),\n    // invalidatedAtoms\n    /* @__PURE__ */ new Set(),\n    // changedAtoms\n    /* @__PURE__ */ new Set(),\n    // mountCallbacks\n    /* @__PURE__ */ new Set(),\n    // unmountCallbacks\n    {},\n    // storeHooks\n    // atom interceptors\n    BUILDING_BLOCK_atomRead,\n    BUILDING_BLOCK_atomWrite,\n    BUILDING_BLOCK_atomOnInit,\n    BUILDING_BLOCK_atomOnMount,\n    // building-block functions\n    BUILDING_BLOCK_ensureAtomState,\n    BUILDING_BLOCK_flushCallbacks,\n    BUILDING_BLOCK_recomputeInvalidatedAtoms,\n    BUILDING_BLOCK_readAtomState,\n    BUILDING_BLOCK_invalidateDependents,\n    BUILDING_BLOCK_writeAtomState,\n    BUILDING_BLOCK_mountDependencies,\n    BUILDING_BLOCK_mountAtom,\n    BUILDING_BLOCK_unmountAtom,\n    BUILDING_BLOCK_setAtomStateValueOrPromise,\n    BUILDING_BLOCK_storeGet,\n    BUILDING_BLOCK_storeSet,\n    BUILDING_BLOCK_storeSub,\n    void 0,\n    // abortable promise support\n    /* @__PURE__ */ new WeakMap(),\n    // abortHandlersMap\n    BUILDING_BLOCK_registerAbortHandler,\n    BUILDING_BLOCK_abortPromise\n  ].map((fn, i) => buildArgs[i] || fn);\n  buildingBlockMap.set(store, Object.freeze(buildingBlocks));\n  return store;\n}\n\nexport { addPendingPromiseToDependency as INTERNAL_addPendingPromiseToDependency, buildStore as INTERNAL_buildStoreRev2, getBuildingBlocks as INTERNAL_getBuildingBlocksRev2, getMountedOrPendingDependents as INTERNAL_getMountedOrPendingDependents, hasInitialValue as INTERNAL_hasInitialValue, initializeStoreHooks as INTERNAL_initializeStoreHooksRev2, isActuallyWritableAtom as INTERNAL_isActuallyWritableAtom, isAtomStateInitialized as INTERNAL_isAtomStateInitialized, isPromiseLike as INTERNAL_isPromiseLike, returnAtomValue as INTERNAL_returnAtomValue };\n", "import { INTERNAL_buildStoreRev2 } from 'jotai/vanilla/internals';\n\nlet keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString() {\n      return (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && this.debugLabel ? key + \":\" + this.debugLabel : key;\n    }\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = defaultRead;\n    config.write = defaultWrite;\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\nfunction defaultRead(get) {\n  return get(this);\n}\nfunction defaultWrite(get, set, arg) {\n  return set(\n    this,\n    typeof arg === \"function\" ? arg(get(this)) : arg\n  );\n}\n\nlet overriddenCreateStore;\nfunction INTERNAL_overrideCreateStore(fn) {\n  overriddenCreateStore = fn(overriddenCreateStore);\n}\nfunction createStore() {\n  if (overriddenCreateStore) {\n    return overriddenCreateStore();\n  }\n  return INTERNAL_buildStoreRev2();\n}\nlet defaultStore;\nfunction getDefaultStore() {\n  if (!defaultStore) {\n    defaultStore = createStore();\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = defaultStore);\n      if (globalThis.__JOTAI_DEFAULT_STORE__ !== defaultStore) {\n        console.warn(\n          \"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\"\n        );\n      }\n    }\n  }\n  return defaultStore;\n}\n\nexport { INTERNAL_overrideCreateStore, atom, createStore, getDefaultStore };\n", "'use client';\nimport React, { createContext, useContext, useRef, createElement, useReducer, useEffect, useDebugValue, useCallback } from 'react';\nimport { getDefaultStore, createStore } from 'jotai/vanilla';\nimport { INTERNAL_getBuildingBlocksRev2 } from 'jotai/vanilla/internals';\n\nconst StoreContext = createContext(\n  void 0\n);\nfunction useStore(options) {\n  const store = useContext(StoreContext);\n  return (options == null ? void 0 : options.store) || store || getDefaultStore();\n}\nfunction Provider({\n  children,\n  store\n}) {\n  const storeRef = useRef(null);\n  if (store) {\n    return createElement(StoreContext.Provider, { value: store }, children);\n  }\n  if (storeRef.current === null) {\n    storeRef.current = createStore();\n  }\n  return createElement(\n    StoreContext.Provider,\n    {\n      // TODO: If this is not a false positive, consider using useState instead of useRef like https://github.com/pmndrs/jotai/pull/2771\n      // eslint-disable-next-line react-hooks/refs\n      value: storeRef.current\n    },\n    children\n  );\n}\n\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nconst attachPromiseStatus = (promise) => {\n  if (!promise.status) {\n    promise.status = \"pending\";\n    promise.then(\n      (v) => {\n        promise.status = \"fulfilled\";\n        promise.value = v;\n      },\n      (e) => {\n        promise.status = \"rejected\";\n        promise.reason = e;\n      }\n    );\n  }\n};\nconst use = React.use || // A shim for older React versions\n((promise) => {\n  if (promise.status === \"pending\") {\n    throw promise;\n  } else if (promise.status === \"fulfilled\") {\n    return promise.value;\n  } else if (promise.status === \"rejected\") {\n    throw promise.reason;\n  } else {\n    attachPromiseStatus(promise);\n    throw promise;\n  }\n});\nconst continuablePromiseMap = /* @__PURE__ */ new WeakMap();\nconst createContinuablePromise = (store, promise, getValue) => {\n  const buildingBlocks = INTERNAL_getBuildingBlocksRev2(store);\n  const registerAbortHandler = buildingBlocks[26];\n  let continuablePromise = continuablePromiseMap.get(promise);\n  if (!continuablePromise) {\n    continuablePromise = new Promise((resolve, reject) => {\n      let curr = promise;\n      const onFulfilled = (me) => (v) => {\n        if (curr === me) {\n          resolve(v);\n        }\n      };\n      const onRejected = (me) => (e) => {\n        if (curr === me) {\n          reject(e);\n        }\n      };\n      const onAbort = () => {\n        try {\n          const nextValue = getValue();\n          if (isPromiseLike(nextValue)) {\n            continuablePromiseMap.set(nextValue, continuablePromise);\n            curr = nextValue;\n            nextValue.then(onFulfilled(nextValue), onRejected(nextValue));\n            registerAbortHandler(store, nextValue, onAbort);\n          } else {\n            resolve(nextValue);\n          }\n        } catch (e) {\n          reject(e);\n        }\n      };\n      promise.then(onFulfilled(promise), onRejected(promise));\n      registerAbortHandler(store, promise, onAbort);\n    });\n    continuablePromiseMap.set(promise, continuablePromise);\n  }\n  return continuablePromise;\n};\nfunction useAtomValue(atom, options) {\n  const { delay, unstable_promiseStatus: promiseStatus = !React.use } = options || {};\n  const store = useStore(options);\n  const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = useReducer(\n    (prev) => {\n      const nextValue = store.get(atom);\n      if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {\n        return prev;\n      }\n      return [nextValue, store, atom];\n    },\n    void 0,\n    () => [store.get(atom), store, atom]\n  );\n  let value = valueFromReducer;\n  if (storeFromReducer !== store || atomFromReducer !== atom) {\n    rerender();\n    value = store.get(atom);\n  }\n  useEffect(() => {\n    const unsub = store.sub(atom, () => {\n      if (promiseStatus) {\n        try {\n          const value2 = store.get(atom);\n          if (isPromiseLike(value2)) {\n            attachPromiseStatus(\n              createContinuablePromise(store, value2, () => store.get(atom))\n            );\n          }\n        } catch (e) {\n        }\n      }\n      if (typeof delay === \"number\") {\n        setTimeout(rerender, delay);\n        return;\n      }\n      rerender();\n    });\n    rerender();\n    return unsub;\n  }, [store, atom, delay, promiseStatus]);\n  useDebugValue(value);\n  if (isPromiseLike(value)) {\n    const promise = createContinuablePromise(\n      store,\n      value,\n      () => store.get(atom)\n    );\n    if (promiseStatus) {\n      attachPromiseStatus(promise);\n    }\n    return use(promise);\n  }\n  return value;\n}\n\nfunction useSetAtom(atom, options) {\n  const store = useStore(options);\n  const setAtom = useCallback(\n    (...args) => {\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !(\"write\" in atom)) {\n        throw new Error(\"not writable atom\");\n      }\n      return store.set(atom, ...args);\n    },\n    [store, atom]\n  );\n  return setAtom;\n}\n\nfunction useAtom(atom, options) {\n  return [\n    useAtomValue(atom, options),\n    // We do wrong type assertion here, which results in throwing an error.\n    useSetAtom(atom, options)\n  ];\n}\n\nexport { Provider, useAtom, useAtomValue, useSetAtom, useStore };\n"],
  "mappings": "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",
  "names": ["atom", "atom", "isPromiseLike", "React", "atom"]
}
